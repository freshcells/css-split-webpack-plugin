{"version":3,"sources":["../src/index.js"],"names":[],"mappings":"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","file":"index.js","sourcesContent":["import postcss from 'postcss';\nimport chunk from './chunk';\nimport SourceMapSource from 'webpack/lib/SourceMapSource';\nimport RawSource from 'webpack/lib/RawSource';\nimport {interpolateName} from 'loader-utils';\n\n/**\n * Detect if a file should be considered for CSS splitting.\n * @param {String} name Name of the file.\n * @returns {Boolean} True if to consider the file, false otherwise.\n */\nconst isCSS = (name : string) : boolean => /\\.css$/.test(name);\n\n/**\n * Remove the trailing `/` from URLs.\n * @param {String} str The url to strip the trailing slash from.\n * @returns {String} The stripped url.\n */\nconst strip = (str : string) : string => str.replace(/\\/$/, '');\n\n/**\n * Create a function that generates names based on some input. This uses\n * webpack's name interpolator under the hood, but since webpack's argument\n * list is all funny this exists just to simplify things.\n * @param {String} input Name to be interpolated.\n * @returns {Function} Function to do the interpolating.\n */\nconst nameInterpolator = (input) => ({file, content, index}) => {\n  const res = interpolateName({\n    context: '/',\n    resourcePath: `/${file}`,\n  }, input, {\n    content,\n  }).replace(/\\[part\\]/g, index + 1);\n  return res;\n};\n\n/**\n * Normalize the `imports` argument to a function.\n * @param {Boolean|String} input The name of the imports file, or a boolean\n * to use the default name.\n * @param {Boolean} preserve True if the default name should not clash.\n * @returns {Function} Name interpolator.\n */\nconst normalizeImports = (input, preserve) => {\n  switch (typeof input) {\n  case 'string':\n    return nameInterpolator(input);\n  case 'boolean':\n    if (input) {\n      if (preserve) {\n        return nameInterpolator('[name]-split.[ext]');\n      }\n      return ({file}) => file;\n    }\n    return () => false;\n  default:\n    throw new TypeError();\n  }\n};\n\n/**\n * Webpack plugin to split CSS assets into multiple files. This is primarily\n * used for dealing with IE <= 9 which cannot handle more than ~4000 rules\n * in a single stylesheet.\n */\nexport default class CSSSplitWebpackPlugin {\n  /**\n   * Create new instance of CSSSplitWebpackPlugin.\n   * @param {Number} size Maximum number of rules for a single file.\n   * @param {Boolean|String} imports Truish to generate an additional import\n   * asset. When a boolean use the default name for the asset.\n   * @param {String} filename Control the generated split file name.\n   * @param {Boolean} preserve True to keep the original unsplit file.\n   */\n  constructor({\n    size = 4000,\n    imports = false,\n    filename = '[name]-[part].[ext]',\n    preserve,\n  }) {\n    this.options = {\n      size,\n      imports: normalizeImports(imports, preserve),\n      filename: nameInterpolator(filename),\n      preserve,\n    };\n  }\n\n  /**\n   * Generate the split chunks for a given CSS file.\n   * @param {String} key Name of the file.\n   * @param {Object} asset Valid webpack Source object.\n   * @returns {Promise} Promise generating array of new files.\n   */\n  file(key : string, asset : Object) {\n    // Use source-maps when possible.\n    const input = asset.sourceAndMap ? asset.sourceAndMap() : {\n      source: asset.source(),\n    };\n    const name = (i) => this.options.filename({\n      ...asset,\n      content: input.source,\n      file: key,\n      index: i,\n    });\n    return postcss([chunk(this.options)]).process(input.source, {\n      map: {\n        prev: input.map,\n      },\n    }).then((result) => {\n      return Promise.resolve({\n        file: key,\n        chunks: result.chunks.map(({css, map}, i) => {\n          return new SourceMapSource(\n            css,\n            name(i),\n            map.toString()\n          );\n        }),\n      });\n    });\n  }\n\n  /**\n   * Run the plugin against a webpack compiler instance. Roughly it walks all\n   * the chunks searching for CSS files and when it finds one that needs to be\n   * split it does so and replaces the original file in the chunk with the split\n   * ones. If the `imports` option is specified the original file is replaced\n   * with an empty CSS file importing the split files, otherwise the original\n   * file is removed entirely.\n   * @param {Object} compiler Compiler instance\n   * @returns {void}\n   */\n  apply(compiler : Object) {\n    // Only run on `this-compilation` to avoid injecting the plugin into\n    // sub-compilers as happens when using the `extract-text-webpack-plugin`.\n    compiler.plugin('this-compilation', (compilation) => {\n      const assets = compilation.assets;\n      const publicPath = strip(compilation.options.output.publicPath || './');\n      compilation.plugin('optimize-chunk-assets', (chunks, done) => {\n        const promises = chunks.map((chunk) => {\n          const input = chunk.files.filter(isCSS);\n          const items = input.map((name) => this.file(name, assets[name]));\n          return Promise.all(items).then((entries) => {\n            entries.forEach((entry) => {\n              // Skip the splitting operation for files that result in no\n              // split occuring.\n              if (entry.chunks.length === 1) {\n                return;\n              }\n              // Inject the new files into the chunk.\n              entry.chunks.forEach((file) => {\n                assets[file._name] = file;\n                chunk.files.push(file._name);\n              });\n              const content = entry.chunks.map((file) => {\n                return `@import \"${publicPath}/${file._name}\";`;\n              }).join('\\n');\n              const imports = this.options.imports({\n                ...entry,\n                content,\n              });\n              if (!this.options.preserve) {\n                chunk.files.splice(chunk.files.indexOf(entry.file), 1);\n                delete assets[entry.file];\n              }\n              if (imports) {\n                assets[imports] = new RawSource(content);\n                chunk.files.push(imports);\n              }\n            });\n            return Promise.resolve();\n          });\n        });\n        Promise.all(promises).then(() => {\n          done();\n        }, done);\n      });\n    });\n  }\n}\n"]}