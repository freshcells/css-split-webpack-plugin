{"version":3,"sources":["../src/chunk.js"],"names":[],"mappings":";;;;;;AAAA;;;;;;;;;;;AAOA,IAAM,eAAe,SAAf,YAAe,CAAC,IAAD,EAAU;AAC7B,MAAI,KAAK,IAAL,KAAc,MAAlB,EAA0B;AACxB,WAAO,KAAK,SAAL,CAAe,MAAtB;AACD;AACD,MAAI,KAAK,IAAL,KAAc,QAAd,IAA0B,KAAK,KAAnC,EAA0C;AACxC,WAAO,IAAI,KAAK,KAAL,CAAW,MAAX,CAAkB,UAAC,IAAD,EAAO,CAAP,EAAa;AACxC,aAAO,OAAO,aAAa,CAAb,CAAd;AACD,KAFU,EAER,CAFQ,CAAX;AAGD;AACD,SAAO,CAAP;AACD,CAVD;;;;;;;;;kBAmBe,kBAAQ,MAAR,CAAe,eAAf,EAAgC,YAKpC;AAAA,mEAAP,EAAO;;AAAA,uBAJT,IAIS;AAAA,MAJT,IAIS,6BAJF,IAIE;AAAA,yBAHT,MAGS;AAAA,MAHD,SAGC,+BAHW,YAAM;AACxB,WAAO,EAAP;AACD,GACQ;;AACT,SAAO,UAAC,GAAD,EAAM,MAAN,EAAiB;AACtB,QAAM,SAAS,EAAf;AACA,QAAI,cAAJ;AACA,QAAI,cAAJ;;;AAGA,QAAM,YAAY,SAAZ,SAAY,GAAM;AACtB,cAAQ,CAAR;AACA,cAAQ,IAAI,KAAJ,CAAU,EAAC,OAAO,EAAR,EAAV,CAAR;AACA,aAAO,IAAP,CAAY,KAAZ;AACD,KAJD;;;;AAQA,QAAI,KAAJ,CAAU,OAAV,CAAkB,UAAC,CAAD,EAAO;AACvB,UAAM,WAAW,aAAa,CAAb,CAAjB;AACA,UAAI,CAAC,KAAD,IAAU,QAAQ,QAAR,GAAmB,IAAjC,EAAuC;AACrC;AACD;AACD,YAAM,KAAN,CAAY,IAAZ,CAAiB,CAAjB;AACA,eAAS,QAAT;AACD,KAPD;;;AAUA,WAAO,MAAP,GAAgB,OAAO,GAAP,CAAW,UAAC,CAAD,EAAI,CAAJ,EAAU;AACnC,aAAO,EAAE,QAAF,CAAW,UAAU,CAAV,EAAa,CAAb,CAAX,CAAP;AACD,KAFe,CAAhB;AAGD,GA3BD;AA4BD,CAlCc,C","file":"chunk.js","sourcesContent":["import postcss from 'postcss';\n\n/**\n * Get the number of selectors for a given node.\n * @param {Object} node CSS node in question.\n * @returns {Number} Total number of selectors associated with that node.\n */\nconst getSelLength = (node) => {\n  if (node.type === 'rule') {\n    return node.selectors.length;\n  }\n  if (node.type === 'atrule' && node.nodes) {\n    return 1 + node.nodes.reduce((memo, n) => {\n      return memo + getSelLength(n);\n    }, 0);\n  }\n  return 0;\n};\n\n/**\n * PostCSS plugin that splits the generated result into multiple results based\n * on number of selectors.\n * @param {Number} size Maximum number of rules in a single file.\n * @param {Function} result Options passed to `postcss.toResult()`\n * @returns {Object} `postcss` plugin instance.\n */\nexport default postcss.plugin('postcss-chunk', ({\n  size = 4000,\n  result: genResult = () => {\n    return {};\n  },\n} = {}) => {\n  return (css, result) => {\n    const chunks = [];\n    let count;\n    let chunk;\n\n    // Create a new chunk that holds current result.\n    const nextChunk = () => {\n      count = 0;\n      chunk = css.clone({nodes: []});\n      chunks.push(chunk);\n    };\n\n    // Walk the nodes. When we overflow the selector count, then start a new\n    // chunk. Collect the nodes into the current chunk.\n    css.nodes.forEach((n) => {\n      const selCount = getSelLength(n);\n      if (!chunk || count + selCount > size) {\n        nextChunk();\n      }\n      chunk.nodes.push(n);\n      count += selCount;\n    });\n\n    // Output the results.\n    result.chunks = chunks.map((c, i) => {\n      return c.toResult(genResult(i, c));\n    });\n  };\n});\n"]}